Đặt vấn đề
Giả sử bạn đang có hệ thống web thông thường chạy qua HTTP/HTTPS (REST API).
Một số tình huống sau sẽ xuất hiện:

Cập nhật thời gian thực
Ví dụ: trang dashboard hiển thị số đơn hàng, trạng thái kho, vị trí xe.
Nếu chỉ có HTTP/REST, client phải “poll” liên tục (gửi GET mỗi 2–3 giây) → lãng phí băng thông + server bị quá tải.
Push dữ liệu từ server về client ngay lập tức

Ví dụ: có đơn hàng mới thì nhân viên phải thấy ngay, không phải reload trang.
HTTP thường là client-initiated, server không tự “push” được.
Trao đổi hai chiều / chat / tracking


Ví dụ: chat hỗ trợ khách hàng, tracking GPS xe giao hàng, notify lỗi real-time.
HTTP thường yêu cầu một request/response mới cho mỗi thông điệp.
Kết nối ổn định, latency thấp

Ví dụ: ứng dụng mobile cần nhận update trong vài trăm ms thay vì polling 5 giây/lần.
HTTP + polling tạo độ trễ cao, không tối ưu pin và mạng trên mobile.


=> Giải pháp với WebSocket
WebSocket là giao thức “nâng cấp” từ HTTP, tạo một kết nối TCP lâu dài, hai chiều:
Server push dữ liệu ngay khi có sự kiện → không cần polling.
Client gửi dữ liệu liên tục mà không mở kết nối mới mỗi lần.
Latency thấp, tiết kiệm băng thông, CPU.
Hoạt động ổn định qua Nginx (proxy_pass với header Upgrade).



| #     | Tình huống                                       | Mô tả                                                          | Vấn đề thực tế khi chỉ dùng HTTP/REST                                                                                                                |
| ----- | ------------------------------------------------ | -------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| **1** | **Cập nhật thời gian thực (Dashboard)**          | Client cần số liệu mới liên tục (đơn hàng, tồn kho, vị trí xe) | – Phải **polling liên tục** (gửi GET 2–3s/lần) → **lãng phí băng thông** <br> – Server phải xử lý hàng loạt request giống nhau, dễ quá tải           |
| **2** | **Push dữ liệu ngay lập tức** (notify order mới) | Server cần chủ động “đẩy” event tới client                     | – HTTP là **client-initiated**; server không tự push được <br> – Phải triển khai **long-polling** phức tạp, kém hiệu quả                             |
| **3** | **Trao đổi hai chiều / Chat / Tracking GPS**     | Cần trao đổi tin nhắn / tọa độ liên tục, thời gian thực        | – HTTP chỉ “1 request – 1 response” <br> – Muốn gửi tin nhắn 2 chiều phải mở **request mới mỗi lần** <br> – Độ trễ cao, tốn CPU, khó quản lý kết nối |
| **4** | **Kết nối ổn định, latency thấp (mobile)**       | Ứng dụng mobile cần update <300ms, tiết kiệm pin và dữ liệu    | – Polling 5s/lần tạo **độ trễ cao** <br> – **Tốn pin & mạng** do liên tục mở/tắt kết nối <br> – Không đảm bảo realtime khi mạng chập chờn            |



| Cách               | Cơ chế                                                                                                 | Tốn băng thông / pin                                                                                                      | Độ trễ                                 |
| ------------------ | ------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------- | -------------------------------------- |
| **Polling (HTTP)** | Cứ 2–3 s client gửi 1 request mới → server trả JSON                                                    | Mỗi lần đều có header HTTP, TCP handshake (nếu chưa reuse), nhiều request rời rạc → tốn băng thông, CPU, pin              | Delay bằng đúng khoảng polling (2–3 s) |
| **WebSocket**      | Client mở 1 TCP+HTTP Upgrade duy nhất → sau đó server push thẳng dữ liệu xuống trên cùng connection đó | Không còn header lặp lại, không mở/đóng connection liên tục → tiết kiệm băng thông, ít wake-up CPU hơn, pin mobile đỡ hao | Gần như realtime (vài ms–trăm ms)      |

// can co co che ping/pong
Bạn có muốn mình viết thêm đoạn ping/pong để giữ kết nối WebSocket sống lâu (tránh timeout của proxy/firewall) không

// co mot nhuoc diem la: neu client co mot yeu cau socket muon ket noi toi server, nhung server chet
=> neu khong co co che reconnect, thi khi server song lai, cac client se khong nhan duoc thong bao

de lam dieu do => can co mot gateway (khong cho phep ket noi truc tiep toi server nua, ma qua mot gateway trung gian (luon song))
| Mô hình                                         | Mô tả                                                                     | Ưu điểm                                                                       | Nhược điểm                                               |
| ----------------------------------------------- | ------------------------------------------------------------------------- | ----------------------------------------------------------------------------- | -------------------------------------------------------- |
| **Gateway chung** (API Gateway kiêm WS Gateway) | Một gateway nhận **tất cả HTTP/REST + WS** rồi route về các microservice. | Triển khai đơn giản, 1 endpoint duy nhất, ít port.                            | Nếu gateway nặng hoặc sự cố sẽ ảnh hưởng cả HTTP lẫn WS. |
| **Gateway chuyên biệt** (WS Gateway riêng)      | API Gateway xử lý HTTP/REST, WS Gateway xử lý WebSocket riêng.            | WS Gateway nhẹ, scale riêng theo số connection; API Gateway tối ưu theo REST. | Phức tạp hơn một chút (hai entry point).                 |

=> cach trien khai:
+ server_lowlatency (service backend)
Không mở WebSocket.
Chỉ nhận request HTTP hoặc xử lý logic.
Khi có dữ liệu mới cần đẩy realtime, nó publish vào một channel Redis (ví dụ lowlatency_channel).

+ gateway_ws (WebSocket Gateway)
Chỉ giữ kết nối WebSocket với client.
Subscribe kênh Redis lowlatency_channel.
Khi Redis có message mới, gateway đẩy xuống tất cả client đang kết nối.

+ client.html (browser)
Connect WebSocket tới ws://gateway_ws (không phải tới backend nữa).
Nhận message realtime từ gateway.


=> ket luan uu diem khi dung gateway ws
| Ưu điểm                 | Mô tả                                                                                                                  |
| ----------------------- | ---------------------------------------------------------------------------------------------------------------------- |
| **Tập trung kết nối**   | Client chỉ connect một nơi. Không phải mở nhiều WS tới nhiều service.                                                  |
| **Backend đơn giản**    | Các service backend không phải xử lý WS connection, chỉ publish message.                                               |
| **Dễ scale**            | Gateway WS scale theo số connection, backend scale theo logic riêng.                                                   |
| **Tách biệt fault**     | Backend down không làm rớt WS client; chỉ cần Redis còn thì gateway vẫn nhận và push khi backend trở lại.              |
| **Hỗ trợ queue/broker** | Có thể dùng Redis Pub/Sub, RabbitMQ, Kafka… tùy yêu cầu. Cần lưu message thì dùng queue, cần realtime nhẹ thì Pub/Sub. |
